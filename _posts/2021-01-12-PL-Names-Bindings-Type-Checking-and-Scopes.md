---
layout: post
title: "[프로그래밍 언어론] 이름, 바인딩, 영역"
author: "Soy-A"
comments: true
tags:
- Programming Language
---

- 명령형 프로그래밍 언어들은 **폰 노이만 구조(von Neumann architecture)**에 대한 추상화이다
> 폰 노이만 구조의 두 가지 주요 요소: 메모리, 프로세서
- 기계의 메모리 셀을 언어로 추상화한 것 -> **변수(variables)**
- 변수는 속성들에 의해 특징지어진다
> **type**, scope, lifetime, ...
<br/><br/>

---

# 이름

- 식별자(identifier)라고도 한다

#### 주요 설계 고려사항

- 이름에 대,소문자가 구별되는가?
- 언어의 특수어가 예약어인가 키워드인가?

---

## 이름 형식

### 길이

- 너무 짧으면 어떤 것을 나타내는지 알기 어려움
- Java, C#, Ada: 길이 제한 X
- C++: 길이 제한X, but 구현자들은 때때로 제한

### 하이픈(-)

- Pascal, Modula-2, FORTRAN 77: 사용 불가

### 대소문자 구분(case sensitivity)

- **readability**를 떨어뜨릴 수 있다
> 대소문자가 섞이면 같아보이지만 다른 이름을 만들 수 있다<br/>

  > C++, Java에는 미리 정의된 이름들이 대소문자 모두를 포함하므로 더 심각하다
- C, C++, Java의 이름: case sensitive하다

### 특수어(special words)

- 수행될 행동들을 명칭화하여 readability 높임
- 문장과 프로그램의 구문 부분을 구별하는 데 사용
> e.g. **end** in Fortran
- **키워드**: 언어의 어떤 문맥에서만 특별한 단어
> e.g. in Fortran<br/>
Integer Apple -> Integer는 이 문장이 선언문이라는 것을 나타내는 **키워드**<br/>
Integer = 4 -> Integer 다음에 '='가 오면, 이는 **변수 이름**으로 고려<br/>
차이를 문맥으로 고려 -> readability 떨어짐
- **예약어**: 이름으로 사용될 수 없는 특수어
> e.g. for, if ,while, static, ... 은 변수 이름으로 사용할 수 없다<br/>

  > 언어가 많은 예약어를 포함하면, 사용자가 예약되지 않은 이름들을 구성하는 데 어려울 수 있다

---

## 변수

- 컴퓨터 메모리 셀이나 셀들의 모임에 대한 추상화
- 변수는 6가지 속성으로 특징지어질 수 있다
> 이름(name), 주소(address), 값(value), 타입(type), 존속기간(lifetime), 영역(scope)

### 이름

- 모든 변수가 이름을 갖는 것은 아니다

### 주소

- 변수와 연관된 기계 메모리 주소
- 동일한 변수가 프로그램 실행 중의 다른 시간에 다른 주소를 가질 수 있다
> e.g.<br/>
```
void f(){
	int a;
}
main(){
	f();	// 변수 a는 메모리의 어딘가에 할당 후 사라짐
	f();	// 변수 a가 다시 어디에 할당될 지는 알 수 없음
}
```
- 두 개 이상의 변수 이름이 동일한 메모리 위치를 접근하는 데 사용될 수 있을 때, 그 변수들을 **별칭(aliases)**이라 함
> e.g. 포인터<br/>

  > 의도하지 않은 값을 바꿀 수 있어 readability를 떨어뜨린다

### 타입

- 변수의 타입은 그 변수가 저장할 수 있는 값들의 범위와 연산들의 집합을 결정한다
> e.g. Java의 int 타입: -2147483648 ~ 2147483647<br/>

<br/><br/>

# 바인딩의 개념

- **바인딩**은 하나의 속성과 하나의 개체 간의 연관이다
 - 변수와 그 타입 또는 값 사이
 - 연산과 기호 사이
- **바인딩 시간**: 바인딩이 일어나는 시기

#### 가능한 바인딩 시간
- 언어 설계 시간
> e.g. 연산자 기호는 언어 설계 시간에 연산에 바인딩 된다
- 언어 구현 시간
> e.g. 데이터 타입은 언어 구현 시간에 가능한 값들의 범위에 바인딩 된다
- 컴파일 시간
> e.g. Java 또는 C 프로그램의 변수는 컴파일 시간에 특정 데이터 타입에 바인딩 된다
- 적재(load) 시간
> e.g. 변수는 프로그램이 메모리에 적재될 때 메모리 셀에 바인딩될 수 있다(C static 변수)
- 실행 시간(run-time)
> 메모리 셀에 nonstatic 지역 변수가 바인딩 된다

> Java의 배정문 예시<br/>
count = count + 5;<br/>
- count의 타입: 컴파일 시간<br/>
- count의 가능한 값들의 집합: 컴파일러 설계 시간<br/>
- count의 값: 실행 시간

---

## 변수의 속성 바인딩

- **정적 바인딩**(static binding): 바인딩이 먼저 **실행 시간 전**에 일어나고 프로그램 실행 전체에 걸쳐서 **변하지 않은 상태**로 남아있는 경우
- **동적 바인딩**(dynamic binding): 바인딩이 먼저 **실행 시간 중**에 일어나거나 프로그램 실행 과정에서 **변경될 수 있는** 경우

### 타입 바인딩

- 타입이 어떻게 명세되는가
- 바인딩이 언제 일어나는가

#### 정적 타입 바인딩(static type binding)

- **명시적 선언(explicit declaration)**: 변수 이름들을 나열하고, 이들이 특정 타입이라는 것을 명세하는 프로그램의 문장
- **묵시적 선언(implicit declaration)**: 선언문보다는 디폴트 규칙을 통해 변수들에게 타입을 연관시키는 수단
> e.g. FORTRAN에서 I-N으로 시작하는 변수는 정수 타입이다
- 묵시적 선언은 writability를 높이나(쓰기 편함), reliability를 떨어뜨린다(실수가 많아질 수 있음)
- **타입 추론(type inference)**: 문맥에 따라 타입이 결정된다

#### 동적 타입 바인딩(dynamic type binding)

- 배정문에서 변수에 어떠한 값이 **할당될 때** 그 변수에 어떠한 **타입이 바인딩**된다(선언문X, 이름의 철자X)
> e.g. Python<br/>
list = [10.2, 3.3, 8];<br/>
list = 47;	\# OK
- 장점: 유연성(포괄적 프로그램)
- 단점: 큰 비용, 신뢰성 떨어짐(컴파일러의 타입 에러 검출 능력이 떨어짐)<br/><br/>

### 기억공간 바인딩과 존속기간

- **할당**(allocation): 변수에 바인딩되는 메모리 셀을 가용 메모리의 풀(pool)로부터 가져오는 과정
- **회수**(deallocation): 변수로부터 바인딩이 해제된 메모리 셀을 다시 가용 메모리의 풀에 반환하는 과정
- **존속기간**(lifetime): 변수가 특정 메모리 위치에 바인딩되어 있는 기간
> 존속기간에 따른 유형 구분: 정적(static), 스택-동적(stack-dynamic), 명시적 힙-동적(explicit heap-dynamic), 묵시적 힙-동적(implicit heap-dynamic)

#### 정적 변수

- 프로그램 실행이 시작되기 **전에 메모리 셀에 바인딩**되며, 프로그램 실행이 **종료될 때까지 동일한 메모리 셀에 바인딩**되어 있는 변수
> e.g. C의 static 변수
- 장점
  - 효율성: 직접 주소 -> 간접보다 빠르다
  - 과거 민감(history sensitive)
- 단점
  - 유연성 감소(재귀 사용 불가 등)

#### 스택-동적 변수

- 선언문이 **세련화될 때 기억공간 바인딩**이 생성되나, **타입은 정적으로 바인딩**되는 변수
- 세련화(elaboration): 선언문에 의해서 지시된 기억공간 할당과 바인딩 과정을 언급
- 장점
  - 재귀 사용 가능
  - 저장공간을 보존
- 단점
  - 할당과 회수에 따른 실행-시간 부담
  - 간접 주소지정으로 인해 더 느린 접근
  - 부프로그램이 과거에 민감할 수 없음
  - 스택 크기에 의해 제한을 받음

#### 명시적 힙-동적 변수

- 프로그래머가 명세하는 **명시적 실행-시간 명령어에 의해서 할당되고 회수**되는 이름이 없는 (추상) 메모리 셀
- 포인터나 참조 변수를 통하여만 참조될 수 있다
> e.g. C++에서의 동적 객체(new와 delete를 통해), Java에서의 모든 객체
- 장점
  - 동적 구조체(연결 리스트, 트리 등)를 구성하는 데 사용됨
- 단점
  - 비효율적
  - 신뢰성 떨어짐

#### 묵시적 힙-동적 변수

- **값이 배정될 때에만 힙 기억 장소에 바인딩**되는 변수
- 할당, 회수는 할당문에 의해서만 일어남
- 장점
  - 유연성
- 단점
  - 비효율적(모든 것을 힙에서 동적으로 처리하기 때문)
  - 에러 검출 능력이 떨어짐

<br/><br/><br/>
**참고 문헌**<br/>
Concepts of Programming Languages, Robert W. Sebesta -10th ed.
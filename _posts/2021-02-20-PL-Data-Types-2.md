---
layout: post
title: "[프로그래밍 언어론] 데이터 타입(2)"
author: "Soy-A"
comments: true
tags:
- Programming Language
---

# 레코드(record) 타입

- 개개의 원소들이 이름으로 식별되고, 그 구조의 시작부분으로부터의 오프셋을 통하여 접근되는 데이터 원소들의 집단체
- C, C++, C#에서, 레코드는 **struct** 데이터 타입

---

## 레코드와 배열의 차이

- 레코드의 원소, 즉 필드들(fields)이 색인으로 참조되지 않는다
- 필드들은 식별자로 명칭되며, 필드에 대한 참조는 식별자를 사용
- 어떤 언어에서의 레코드는 공용체(union)를 포함하는 것이 허용됨
- 배열의 원소에 접근하는 것이 레코드 필드에 접근하는 것보다 훨씬 느림(필드 이름은 정적)

## 레코드 필드의 참조

- **완전 자격 참조**(fully qualifed reference)는 가장 큰 포괄적인 레코드부터 특정 필드에 이르기까지 모든 중간 레코드 이름들이 그 참조에 포함된다
> 대부분 도트 표기법(dot notation) 이용
- **생략 참조**(elliptical reference)는 참조가 **모호하지 않은 경우**에 한해 레코드 이름을 생략하는 것을 허용
> in COBOL
>- **full qualified reference**: Middle OF EMPLOYEE-NAME OF EMPLOYEE-RECORD
>- **elliptical reference**: FIRST/ FIRST OF EMPLOYEE-NAME / FIRST OF EMPLOYEE-RECORD

## 레코드 필드의 구현

- 레코드 필드들은 인접된 메모리 위치들에 저장됨
- 오프셋 주소: 레코드의 시작 주소에 상대적이며, 필드 접근들은 모두 이러한 오프셋을 사용하여 처리됨
- 오프셋을 가지면 메모리가 어디에 배정되든 쉽게 찾을 수 있다

# 공용체(union) 타입

- 그 변수가 프로그램 실행 중 다른 시기에 다른 타입의 값을 저장할 수 있는 타입
- struct는 갖고있는 타입별로 자리가 할당되지만, union은 갖고있는 타입 중 가장 큰 타입만큼만 할당됨

## 판별(discriminated) 공용체와 자유(free) 공용체

### 자유 공용체

- Fortran(equivalence), C, C++(union)
- 프로그래머는 그 사용에 있어서 타입 검사로부터 완전한 자유가 허용됨
- 한마디로 type checking 안함

### 판별 공용체

- ALGOL 68, Ada
- 각 공용체 구조가 타입 지시자를 포함함
- type checking 함

# 리스트(list) 타입

- Scheme과 Common LISP의 리스트는 괄호로 구분되고, 원소들은 어떤 구분자도 구분되지 않음
> e.g. (A B C D)
- Python의 리스트는 배열로서도 역할함
  - 변경 가능함(mutable)
  - 어떤 데이터 값이나 객체도 포함 가능
> e.g. myList = [3, 5, 8, 'apple']

# 튜플(tuple) 타입

- 튜플은 **원소들이 명명되지 않는다**는 것을 제외하면 레코드와 유사함
- 변경 불가(immutable)
- 튜플이 변경될 필요가 있으면 list 함수를 사용해 배열로 변환할 수 있다(python)
> in python<br/>
myTuple = (3, 5.8, 'apple')<br/>
print(myTuple[1]) -> 5.8<br/>
myTuple[1] = 10 -> X

# 포인터 타입과 참조 타입

## 포인터 타입

- 포인터 타입은 그 변수가 메모리 주소와 특수 값 nil(null)로 구성되는 값들의 범위를 갖는 타입

### 포인터의 두 가지 용도(중요)
1. 포인터는 간접 주소지정의 어떤 능력을 제공
2. 포인터는 동적 기억공간을 관리하는 한 가지 방식을 제공
  - 포인터는 동적으로 할당되는 **힙**이라 불리는 기억공간 영역의 한 위치 접근에 사용될 수 있다 

<br/>
- **힙-동적 변수**: 힙으로부터 동적으로 할당되는 변수
  - 단지 포인터나 참조 타입 변수들에 의해서만 참조 가능
- **무명 변수**: 이름이 없는 변수들

- 포인터는 타입 연산자(* 또는 access 등)를 사용하여 정의되지만, 배열이나 레코드와는 다르게 구조화된 타입이 아님

### 포인터의 문제

#### 허상 포인터(dangling pointer)

- 이미 회수된 힙-동적 변수의 주소를 포함하는 포인터
- 다음과 같은 연산은 허상 포인터를 생성함
  1. 힙-동적 변수 생성, 포인터 p1이 그 변수 가리키도록 설정
  2. 포인터 p2에 p1값 할당
  3. p1이 가리키는 힙-동적 변수 회수

#### 분실된 힙-동적 변수

- 사용자 프로그램에서 더 이상 접근될 수 없는 할당된 힙-동적 변수
- 쓰이지 않고 자리 차지만 함
- 다음과 같은 연산을 통해 생성됨
  1. 포인터 p1이 새롭게 생성된 힙-동적 변수를 가리키도록 설정됨
  2. p1이 나중에 새롭게 생성된 또 다른 힙-동적 변수를 가리키도록 설정됨
- 이처럼 힙-동적 변수를 분실하는 것을 **메모리 누수(memory leakage)**라고 부르며, 이는 힙 공간을 모자라게 할 수 있음

### C와 C++의 포인터

- 포인터는 주소가 어셈블리어에서 사용되는 것과 동일한 방식으로 사용될 수 있다.
- 동적 저장공간 관리와 주소 생성에 사용된다.
- 역참조 연산(*), 변수의 주소를 생성하기 위한 연산자(&)
- 도메인 타입은 고정되지 않아도 됨
> e.g. **void \***
>- 어떤 타입이든 가리킬 수 있으며, 타입 검사가 가능
>- 역참조될 수 없다. 함수의 매개변수 타입으로서 사용됨<br/><br/>
**void \*** 포인터는 왜 필요한가?<br/>
>- type을 명확히 알 수 없는 경우 필요

## 참조(reference) 타입

- 포인터는 메모리의 주소를 참조
- but 참조 변수는 **메모리의 객체나 값**을 참조
- C++ 참조 타입 변수는 항상 묵시적으로 역참조되는 상수(constant) 포인터임
- 따라서 어떤 변수의 주소 값으로 초기화 되어야 하고, 초기화 후에는 다른 변수를 참조하도록 설정될 수 없음
- 한마디로, 포인터는 역참조 따로 해줘야 하지만(* 이용, 그 포인터 변수가 딴 걸 가리키고 있을 수도 있으므로) 참조 타입은 알아서 됨(표시 안해도 ok).
>int result = 0;<br/>
int &ref_result = result;	// -> result와 ref_result는 aliases임(표시 안해도)<br/>
...<br/>
ref_result = 100;	// result == 100, 만약 &없었다면 0, 여기서 ref_result는 항상 dereference하는 상태

### Java

- **Only 참조**
- 모든 자바 클래스 사례들은 참조 변수에 의해서 참조됨
>e.g.<br/>
String str1;<br/>
...<br/>
str1 = "This is a Java literal string";<br/>
-> str1은 String 클래스 사례, 즉 객체를 참조하도록 정의됨
- 객체만 가리킬 수 있다
- **명시적 회수 불가**(delete 없음) -> **garbage collector**가 사용됨 -> dangling reference 생기지 않는다
- 항상 묵시적으로 회수됨

### 허상 포인터(dangling pointer) 문제의 해결책

#### 비석 접근 방법(Tombstone)

- **tombstone**: 힙-동적 변수에 대한 포인터, 추가적인 힙 셀
- 실제 포인터 변수는 tombstone만을 가리키고 힙-동적 변수를 가리키지 않음
- 힙-동적 변수가 회수될 때, 비석은 그대로 남으나 nil을 가리키도록 설정됨 -> 포인터가 회수된 변수를 계속 가리키는 것 방지
- 시간, 공간적으로 비용 듦(더 많은 간접 주소지정, 비석은 회수되지 않음)
<img width="765" alt="스크린샷 2021-03-09 오전 10 24 00" src="https://user-images.githubusercontent.com/63772786/110404082-91e9e380-80c1-11eb-8747-f99021e688d2.png">

#### 잠금-키 접근 방법(Locks and keys)

- 포인터 값은 순서 쌍(키, 주소)으로 표현됨
- 힙-동적 변수는 그 변수와 정수 잠금 값을 저장하는 헤더 셀을 위한 기억공간으로 표현됨
- 힙-동적 변수가 할당될 때, 잠금 값이 생성되어 힙-동적 변수의 잠금 셀과 new의 호출에 명세된 포인터의 키 셀에 모두 저장됨
- 역참조된 포인터에 대한 모든 접근은 이 포인터의 키 값을 힙-동적 변수의 잠금 값과 비교함
- 힙-동적 변수가 회수되면, 그 잠금 값은 적법하지 않은 잠금 값으로 변경됨

### 힙 메모리 관리

- 힙 메모리 관리는 매우 복잡한 실행 시간 프로세스일 수 있음
>single-size segment: 모든 힙 기억공간이 동일한 크기의 단위로 할당, 회수되는 상황<br/>
variable-size segment: 가변 크기의 세그먼트가 할당되고 회수되는 상황

#### 단일 크기의 셀

- 쉬운 할당 / 복잡한 회수
- 회수 두 가지 기법: **reference counters**(eager approach: 조기 접근 방법) vs. **garbage collection**(lazy approach: 지연 접근 방법)

##### Reference counters

- 모든 셀에 대해서 현재 자신을 가리키고 있는 포인터들의 개수를 저장하는 계수기(counter)를 유지시킨다.
- 단점
  - 공간 요구됨
  - 실행 시간 요구됨
  - 셀들의 모임이 순환적으로 연결되어 있다면 복잡해짐(counting이 섞여있다면 잘 작동하지 않는다)

##### Gargabe collection

- 가용 기억공간의 모든 셀들이 할당될 때까지 기억공간 셀들을 할당하고, 필요할 때 포인터들을 셀로부터 분리시킴. 그리고 나서 힙 공간의 모든 쓰레기를 모으기 시작.
- 힙 공간의 모든 셀은 그 수집 알고리즘에서 사용되는 여분의 지시자인 비트나 필드 갖는다.
- 표시-수집(mark-sweep)과정의 세 단계
  1. 힙 상의 모든 셀들은 그들이 쓰레기라는 것을 나타내도록 지시자가 설정됨
  2. 모든 포인터들이 힙 공간에서 추적되고, 도달 가능한 모든 셀들은 쓰레기가 아닌 것으로 표시됨
  3. 모든 garbage 셀들은 가용 공간 리스트에 반환됨
- 단점: 즉시 없애는 게 아니고, 마크해뒀다가 필요할 때 없애므로 드물게 수행된다.

#### 가변 크기의 셀

- 가변-크기 셀들이 할당되는 힙 메모리를 관리하는 것은 단일-크기 셀을 위한 힙 메모리를 관리하는데 따른 모든 어려움을 포함할 뿐 아니라 문제들을 추가로 포함함
- 할당
  - 가변-크기 셀을 할당하기에 충분한 블록 서치
  - First-fit, best-fit
  - 단편화(fragmentation)
- 회수
  - 사용가능한 공간의 리스트를 유지하는 것은 또 다른 부담요소.
  - 인접된 블록들을 합병하여 충분한 크기의 블록 생성 필요

# 타입 검사(type checking)

- 타입 검사는 연산자에 포함된 피연산자들이 호환 가능한 타입인지를 확인하는 것
- **호환 가능 타입(compatible type)**이란 연산자에 대해서 적법하거나, 컴파일러-생성 코드에 의해서 적법한 타입으로 묵시적으로 변환되는 것이 허용되는 타입
- 이러한 자동 변환을 타입 **강제 변환(coercion)**이라고 함
> Java에서 int 형 변수와 float 형 변수가 더해지면, int의 값은 float로 강제 변환됨
- 타입 오류(type error)는 부적절한 타입을 갖는 피연산자에 대한 연산자의 적용을 의미
- 타입들에 대한 변수들의 모든 바인딩이 정적이면, 타입 검사는 거의 항상 정적으로 수행 가능
- 타입 바인딩이 동적이면, 타입 검사는 동적이어야만 함
- 프로그래밍 언어는 타입 오류가 항상 탐지되면 **강 타입 언어(strongly typed language)**임
> strongly typed language: 모든 타입 detection 가능<br/>
C, C++은 strongly typed까진 아님 -> union은 type checking 안하기 때문

# 강 타입(Strong typing)

- 장점: 타입 오류를 초래하는 변수들의 모든 잘못된 사용을 탐지할 수 있다.
>강 타입 언어의 예<br/>
**Ada**: 거의 강 타입임(Java도 비슷)<br/>
**C, C++**: 타입 검사가 되지 않는 union 타입을 포함하기 때문에 강 타입 언어가 아님<br/>
Ada > Java > C/C++

- 강제 변환 규칙(coercion rules)은 문제 일으킬 수 있음
> 오타로 인한 에러를 넘어가 버린다면 reliability를 떨어뜨린다.



<br/><br/><br/>
**참고 문헌**<br/>
Concepts of Programming Languages, Robert W. Sebesta -10th ed.

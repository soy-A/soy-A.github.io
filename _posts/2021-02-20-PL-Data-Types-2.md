---
layout: post
title: "[프로그래밍 언어론] 데이터 타입(2)"
author: "Soy-A"
comments: true
tags:
- Programming Language
---

# 레코드(record) 타입

- 개개의 원소들이 이름으로 식별되고, 그 구조의 시작부분으로부터의 오프셋을 통하여 접근되는 데이터 원소들의 집단체
- C, C++, C#에서, 레코드는 **struct** 데이터 타입

---

## 레코드와 배열의 차이

- 레코드의 원소, 즉 필드들(fields)이 색인으로 참조되지 않는다
- 필드들은 식별자로 명칭되며, 필드에 대한 참조는 식별자를 사용
- 어떤 언어에서의 레코드는 공용체(union)를 포함하는 것이 허용됨
- 배열의 원소에 접근하는 것이 레코드 필드에 접근하는 것보다 훨씬 느림(필드 이름은 정적)

## 레코드 필드의 참조

- **완전 자격 참조**(fully qualifed reference)는 가장 큰 포괄적인 레코드부터 특정 필드에 이르기까지 모든 중간 레코드 이름들이 그 참조에 포함된다
> 대부분 도트 표기법(dot notation) 이용
- **생략 참조**(elliptical reference)는 참조가 **모호하지 않은 경우**에 한해 레코드 이름을 생략하는 것을 허용
> in COBOL
>- **full qualified reference**: Middle OF EMPLOYEE-NAME OF EMPLOYEE-RECORD
>- **elliptical reference**: FIRST/ FIRST OF EMPLOYEE-NAME / FIRST OF EMPLOYEE-RECORD

## 레코드 필드의 구현

- 레코드 필드들은 인접된 메모리 위치들에 저장됨
- 오프셋 주소: 레코드의 시작 주소에 상대적이며, 필드 접근들은 모두 이러한 오프셋을 사용하여 처리됨
- 오프셋을 가지면 메모리가 어디에 배정되든 쉽게 찾을 수 있다

# 공용체(union) 타입

- 그 변수가 프로그램 실행 중 다른 시기에 다른 타입의 값을 저장할 수 있는 타입
- struct는 갖고있는 타입별로 자리가 할당되지만, union은 갖고있는 타입 중 가장 큰 타입만큼만 할당됨

## 판별(discriminated) 공용체와 자유(free) 공용체

### 자유 공용체

- Fortran(equivalence), C, C++(union)
- 프로그래머는 그 사용에 있어서 타입 검사로부터 완전한 자유가 허용됨
- 한마디로 type checking 안함

### 판별 공용체

- ALGOL 68, Ada
- 각 공용체 구조가 타입 지시자를 포함함
- type checking 함

# 리스트(list) 타입

- Scheme과 Common LISP의 리스트는 괄호로 구분되고, 원소들은 어떤 구분자도 구분되지 않음
> e.g. (A B C D)
- Python의 리스트는 배열로서도 역할함
  - 변경 가능함(mutable)
  - 어떤 데이터 값이나 객체도 포함 가능
> e.g. myList = [3, 5, 8, 'apple']

# 튜플(tuple) 타입

- 튜플은 **원소들이 명명되지 않는다**는 것을 제외하면 레코드와 유사함
- 변경 불가(immutable)
- 튜플이 변경될 필요가 있으면 list 함수를 사용해 배열로 변환할 수 있다(python)
> in python<br/>
myTuple = (3, 5.8, 'apple')<br/>
print(myTuple[1]) -> 5.8<br/>
myTuple[1] = 10 -> X

# 포인터 타입과 참조 타입

## 포인터 타입

- 포인터 타입은 그 변수가 메모리 주소와 특수 값 nil(null)로 구성되는 값들의 범위를 갖는 타입

### 포인터의 두 가지 용도(중요)
1. 포인터는 간접 주소지정의 어떤 능력을 제공
2. 포인터는 동적 기억공간을 관리하는 한 가지 방식을 제공
  - 포인터는 동적으로 할당되는 **힙**이라 불리는 기억공간 영역의 한 위치 접근에 사용될 수 있다 

<br/>
- **힙-동적 변수**: 힙으로부터 동적으로 할당되는 변수
  - 단지 포인터나 참조 타입 변수들에 의해서만 참조 가능
- **무명 변수**: 이름이 없는 변수들

- 포인터는 타입 연산자(* 또는 access 등)를 사용하여 정의되지만, 배열이나 레코드와는 다르게 구조화된 타입이 아님

### 포인터의 문제

#### 허상 포인터(dangling pointer)

- 이미 회수된 힙-동적 변수의 주소를 포함하는 포인터
- 다음과 같은 연산은 허상 포인터를 생성함
  1. 힙-동적 변수 생성, 포인터 p1이 그 변수 가리키도록 설정
  2. 포인터 p2에 p1값 할당
  3. p1이 가리키는 힙-동적 변수 회수

#### 분실된 힙-동적 변수

- 사용자 프로그램에서 더 이상 접근될 수 없는 할당된 힙-동적 변수
- 쓰이지 않고 자리 차지만 함
- 다음과 같은 연산을 통해 생성됨
  1. 포인터 p1이 새롭게 생성된 힙-동적 변수를 가리키도록 설정됨
  2. p1이 나중에 새롭게 생성된 또 다른 힙-동적 변수를 가리키도록 설정됨
- 이처럼 힙-동적 변수를 분실하는 것을 **메모리 누수(memory leakage)**라고 부르며, 이는 힙 공간을 모자라게 할 수 있음

### C와 C++의 포인터

- 포인터는 주소가 어셈블리어에서 사용되는 것과 동일한 방식으로 사용될 수 있다.
- 동적 저장공간 관리와 주소 생성에 사용된다.
- 역참조 연산(*), 변수의 주소를 생성하기 위한 연산자(&)
- 도메인 타입은 고정되지 않아도 됨
> e.g. **void \***
>- 어떤 타입이든 가리킬 수 있으며, 타입 검사가 가능
>- 역참조될 수 없다. 함수의 매개변수 타입으로서 사용됨<br/><br/>
**void \*** 포인터는 왜 필요한가?<br/>
>- type을 명확히 알 수 없는 경우 필요

## 참조(reference) 타입

- 포인터는 메모리의 주소를 참조
- but 참조 변수는 **메모리의 객체나 값**을 참조
- C++ 참조 타입 변수는 항상 묵시적으로 역참조되는 상수(constant) 포인터임
- 따라서 어떤 변수의 주소 값으로 초기화 되어야 하고, 초기화 후에는 다른 변수를 참조하도록 설정될 수 없음
- 한마디로, 포인터는 역참조 따로 해줘야 하지만(* 이용, 그 포인터 변수가 딴 걸 가리키고 있을 수도 있으므로) 참조 타입은 알아서 됨(표시 안해도 ok).
>int result = 0;<br/>
int &ref_result = result;	// -> result와 ref_result는 aliases임(표시 안해도)<br/>
...<br/>
ref_result = 100;	// result == 100, 만약 &없었다면 0, 여기서 ref_result는 항상 dereference하는 상태

### Java

- **Only 참조**
- 모든 자바 클래스 사례들은 참조 변수에 의해서 참조됨
>e.g.<br/>
String str1;<br/>
...<br/>
str1 = "This is a Java literal string";<br/>
-> str1은 String 클래스 사례, 즉 객체를 참조하도록 정의됨
- 객체만 가리킬 수 있다
- **명시적 회수 불가**(delete 없음) -> **garbage collector**가 사용됨 -> dangling reference 생기지 않는다
- 항상 묵시적으로 회수됨





<br/><br/><br/>
**참고 문헌**<br/>
Concepts of Programming Languages, Robert W. Sebesta -10th ed.
